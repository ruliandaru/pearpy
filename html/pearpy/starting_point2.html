<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pearpy.starting_point2 API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pearpy.starting_point2</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
from dataclasses import dataclass
from pathlib import Path
from shutil import copy2
from tempfile import TemporaryDirectory
from typing import Any, Callable, Dict, Generator, List, Optional, Tuple, Union

import fiona
import geosardine as dine
import numpy as np
import rasterio
import shapely
import whitebox
from rasterio import Affine
from rasterio.features import geometry_mask
from shapely import geometry, ops, speedups
from shapely.geometry import LineString, Point
from tqdm.autonotebook import tqdm

from pearpy.starting_point import find_starting_point

from .custom_types import GeoJsonDict

speedups.disable()

wbt = whitebox.WhiteboxTools()


class StemTooShort(Exception):
    pass


class ProcessingData:
    def __init__(self, flow_direction, flow_stream):
        self.temp_folder = TemporaryDirectory()
        self.temp_path = Path(self.temp_folder.name)
        self.flow_direction = flow_direction
        self.flow_stream = flow_stream

        self.main_stem_rasterfile = self.temp_path / &#34;main_stem.tif&#34;
        self.main_stem_vectorfile = self.temp_path / &#34;main_stem.shp&#34;
        self.link_class_file = self.temp_path / &#34;link_class.tif&#34;

        self.link_class: Optional[&#34;dine.Raster&#34;] = None

        self.generate()

    def generate(self) -&gt; None:
        wbt.find_main_stem(
            self.flow_direction,
            self.flow_stream,
            self.main_stem_rasterfile,
            esri_pntr=True,
        )
        wbt.stream_link_class(
            self.flow_direction, self.flow_stream, self.link_class_file, esri_pntr=True
        )
        wbt.raster_streams_to_vector(
            self.main_stem_rasterfile,
            self.flow_direction,
            self.main_stem_vectorfile,
            esri_pntr=True,
        )

        self.link_class = dine.Raster.from_rasterfile(str(self.link_class_file))
        print(&#34;processing data has been generated&#34;)

    def save(self, output_directory: Path) -&gt; None:
        # self.link_class.save(str(output_directory / &#34;link_class.tif&#34;))
        for f in self.temp_path.glob(&#34;*&#34;):
            if f.is_file():
                copy2(f.absolute(), output_directory)

    def cleanup(self) -&gt; None:
        self.temp_folder.cleanup()


def interpolate_points(
    polyline: geometry.LineString, distance: float = 0.25, upstream: int = 0
) -&gt; Generator[geometry.Point, None, None]:
    interpolate_distances = np.arange(polyline.length // distance) * distance
    interpolate_distances = np.append(interpolate_distances, polyline.length)
    for interpolate_distance in interpolate_distances:
        yield polyline.interpolate(interpolate_distance)


def estimate_volume(array: np.ndarray, dsm_diff: dine.Raster) -&gt; float:
    return float(
        np.sum(array[(array &gt; dsm_diff.no_data) &amp; (array &gt; 0)]) * dsm_diff.resolution[0]
    )


def calculate_volume_stem(
    stem: geometry.LineString,
    point: geometry.Point,
    dsm_diff: &#34;dine.Raster&#34;,
    stream_buffer_size: float,
) -&gt; float:
    splited = ops.split(stem, point.buffer(0.1))
    if splited[0].length &lt; dsm_diff.resolution[0] * 5:
        raise StemTooShort
    mask = geometry_mask(
        [geometry.mapping(splited[0].buffer(stream_buffer_size))],
        transform=dsm_diff.transform,
        out_shape=dsm_diff.shape[:2],
    )
    return (
        dsm_diff.array[
            (~mask.reshape(mask.shape[0], mask.shape[1], 1))
            &amp; (dsm_diff &gt; 0)
            &amp; (dsm_diff != dsm_diff.no_data)
        ]
        * dsm_diff.resolution[0]
    ).sum()


def find_starting_point(
    stem: geometry.LineString,
    ditance: float,
    dsm_diff: &#34;dine.Raster&#34;,
    link_class: &#34;dine.Raster&#34;,
    stream_buffer_size: float,
) -&gt; Tuple[Optional[geometry.Point], Optional[float]]:

    if stem.length &lt; 100:
        return None, None

    buffer_pixel = 5
    buffer_area = (buffer_pixel * 2) ** 2
    minimum_pixel = buffer_area * 0.5

    point_in_stem = interpolate_points(stem, ditance)

    sp_candidates: List[geometry.Point] = []
    sp_candidates_junction: List[geometry.Point] = []
    for point in point_in_stem:
        point_diff = dsm_diff.xy_value(point.x, point.y)
        if point_diff != dsm_diff.no_data and point_diff &gt;= 0:
            row, col = dsm_diff.xy2rowcol(point.x, point.y)

            bounding_box = np.array(
                [
                    row - buffer_pixel,
                    col - buffer_pixel,
                    row + buffer_pixel,
                    col + buffer_pixel,
                ]
            )

            if np.all(bounding_box &gt; 0) and dsm_diff.array[row, col] &gt; 0:
                buffered_point = dsm_diff.array[
                    bounding_box[0] : bounding_box[2], bounding_box[1] : bounding_box[3]
                ]
                deposition_pixel_count: int = (buffered_point &gt; 0).sum()
                if deposition_pixel_count &gt; minimum_pixel:
                    if link_class.xy_value(point.x, point.y)[0] == 4:
                        sp_candidates_junction.append(point)
                    else:
                        sp_candidates.append(point)

    if len(sp_candidates_junction) &gt; 0:
        starting_point = sp_candidates_junction[-1]
    elif len(sp_candidates) &gt; 0:
        starting_point = sp_candidates[-1]
    else:
        starting_point = None

    if starting_point is not None:
        try:
            volume = calculate_volume_stem(
                stem, starting_point, dsm_diff, stream_buffer_size
            )
        except StemTooShort:
            row, col = dsm_diff.xy2rowcol(starting_point.x, starting_point.y)

            bounding_box = np.array(
                [
                    row - buffer_pixel,
                    col - buffer_pixel,
                    row + buffer_pixel,
                    col + buffer_pixel,
                ]
            )

            buffered_point = dsm_diff.array[
                bounding_box[0] : bounding_box[2], bounding_box[1] : bounding_box[3]
            ]
            volume = estimate_volume(
                buffered_point[buffered_point != dsm_diff.no_data],
                dsm_diff,
            )
    else:
        volume = None

    return starting_point, volume


def find_starting_points(
    input_earlier_dsm: str,
    input_later_dsm: str,
    input_flow_direction: str,
    input_flow_stream: str,
    max_percent_length: float,
    stream_buffer_size: float,
    return_processing_data: bool = False,
    progress_callback: Optional[Callable[[int, int], None]] = None,
) -&gt; Tuple[List[Tuple[Point, float]], Optional[ProcessingData]]:
    if progress_callback is not None:
        progress_callback(0, 0)
    processing_data = ProcessingData(input_flow_direction, input_flow_stream)

    try:
        print(processing_data.main_stem_vectorfile)
        print(&#34;r&#34;,input_earlier_dsm, input_later_dsm)
        with fiona.open(processing_data.main_stem_vectorfile) as lines, rasterio.open(
            input_earlier_dsm
        ) as earlier_dsm, rasterio.open(input_later_dsm) as later_dsm:
            earlier_dsm = dine.Raster.from_rasterfile(input_earlier_dsm)
            later_dsm = dine.Raster.from_rasterfile(input_later_dsm)

            if later_dsm.epsg != earlier_dsm.epsg:
                raise ValueError(&#34;Both dsm should be in the same reference system&#34;)

            dsm_diff = later_dsm - earlier_dsm

            starting_points: List[Tuple[Point, float]] = []
            sp_coordinates: np.ndarray = np.empty((1, 2), dtype=np.float32)

            features: Tuple[Tuple[int, GeoJsonDict], ...] = tuple(
                lines.items(
                    bbox=(
                        later_dsm.x_min,
                        later_dsm.y_min,
                        later_dsm.x_max,
                        later_dsm.y_max,
                    )
                )
            )

            progress_total = len(features)

            for i, feature in tqdm(features, total=len(features)):

                line = feature[&#34;geometry&#34;][&#34;coordinates&#34;]
                if later_dsm.xy_value(
                    *feature[&#34;geometry&#34;][&#34;coordinates&#34;][0]
                ) &lt; later_dsm.xy_value(*feature[&#34;geometry&#34;][&#34;coordinates&#34;][-1]):
                    line = feature[&#34;geometry&#34;][&#34;coordinates&#34;][::-1]

                stem = geometry.LineString(line)
                stem = ops.substring(stem, 0, stem.length * max_percent_length / 100)

                starting_point, volume = find_starting_point(
                    stem, 0.25, dsm_diff, processing_data.link_class, stream_buffer_size
                )
                if starting_point is not None and volume is not None:
                    near_sp_exist = any(
                        (
                            np.abs(sp_coordinates[:, 0] - starting_point.x)
                            + np.abs(sp_coordinates[:, 1] - starting_point.y)
                        )
                        &lt;= 3
                    )

                    if not near_sp_exist:
                        starting_points.append((starting_point, volume))

                if progress_callback is not None:
                    progress_callback(progress_total, i + 1)
            if return_processing_data:
                return starting_points, processing_data
            else:
                # processing_data.cleanup()
                return starting_points, None
    except Exception as e:
        processing_data.cleanup()
        raise e


def save2txt(
    starting_points: List[Tuple[Point, float]], output_location: Union[Path, str]
) -&gt; None:
    with open(output_location, &#34;w&#34;) as out:
        for starting_point, volume in starting_points:
            out.writelines(f&#34;{starting_point.x},{starting_point.y},{volume}\n&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pearpy.starting_point2.calculate_volume_stem"><code class="name flex">
<span>def <span class="ident">calculate_volume_stem</span></span>(<span>stem: shapely.geometry.linestring.LineString, point: shapely.geometry.point.Point, dsm_diff: dine.Raster, stream_buffer_size: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_volume_stem(
    stem: geometry.LineString,
    point: geometry.Point,
    dsm_diff: &#34;dine.Raster&#34;,
    stream_buffer_size: float,
) -&gt; float:
    splited = ops.split(stem, point.buffer(0.1))
    if splited[0].length &lt; dsm_diff.resolution[0] * 5:
        raise StemTooShort
    mask = geometry_mask(
        [geometry.mapping(splited[0].buffer(stream_buffer_size))],
        transform=dsm_diff.transform,
        out_shape=dsm_diff.shape[:2],
    )
    return (
        dsm_diff.array[
            (~mask.reshape(mask.shape[0], mask.shape[1], 1))
            &amp; (dsm_diff &gt; 0)
            &amp; (dsm_diff != dsm_diff.no_data)
        ]
        * dsm_diff.resolution[0]
    ).sum()</code></pre>
</details>
</dd>
<dt id="pearpy.starting_point2.estimate_volume"><code class="name flex">
<span>def <span class="ident">estimate_volume</span></span>(<span>array: numpy.ndarray, dsm_diff: geosardine.raster.Raster) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_volume(array: np.ndarray, dsm_diff: dine.Raster) -&gt; float:
    return float(
        np.sum(array[(array &gt; dsm_diff.no_data) &amp; (array &gt; 0)]) * dsm_diff.resolution[0]
    )</code></pre>
</details>
</dd>
<dt id="pearpy.starting_point2.find_starting_point"><code class="name flex">
<span>def <span class="ident">find_starting_point</span></span>(<span>stem: shapely.geometry.linestring.LineString, ditance: float, dsm_diff: dine.Raster, link_class: dine.Raster, stream_buffer_size: float) ‑> typing.Tuple[typing.Optional[shapely.geometry.point.Point], typing.Optional[float]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_starting_point(
    stem: geometry.LineString,
    ditance: float,
    dsm_diff: &#34;dine.Raster&#34;,
    link_class: &#34;dine.Raster&#34;,
    stream_buffer_size: float,
) -&gt; Tuple[Optional[geometry.Point], Optional[float]]:

    if stem.length &lt; 100:
        return None, None

    buffer_pixel = 5
    buffer_area = (buffer_pixel * 2) ** 2
    minimum_pixel = buffer_area * 0.5

    point_in_stem = interpolate_points(stem, ditance)

    sp_candidates: List[geometry.Point] = []
    sp_candidates_junction: List[geometry.Point] = []
    for point in point_in_stem:
        point_diff = dsm_diff.xy_value(point.x, point.y)
        if point_diff != dsm_diff.no_data and point_diff &gt;= 0:
            row, col = dsm_diff.xy2rowcol(point.x, point.y)

            bounding_box = np.array(
                [
                    row - buffer_pixel,
                    col - buffer_pixel,
                    row + buffer_pixel,
                    col + buffer_pixel,
                ]
            )

            if np.all(bounding_box &gt; 0) and dsm_diff.array[row, col] &gt; 0:
                buffered_point = dsm_diff.array[
                    bounding_box[0] : bounding_box[2], bounding_box[1] : bounding_box[3]
                ]
                deposition_pixel_count: int = (buffered_point &gt; 0).sum()
                if deposition_pixel_count &gt; minimum_pixel:
                    if link_class.xy_value(point.x, point.y)[0] == 4:
                        sp_candidates_junction.append(point)
                    else:
                        sp_candidates.append(point)

    if len(sp_candidates_junction) &gt; 0:
        starting_point = sp_candidates_junction[-1]
    elif len(sp_candidates) &gt; 0:
        starting_point = sp_candidates[-1]
    else:
        starting_point = None

    if starting_point is not None:
        try:
            volume = calculate_volume_stem(
                stem, starting_point, dsm_diff, stream_buffer_size
            )
        except StemTooShort:
            row, col = dsm_diff.xy2rowcol(starting_point.x, starting_point.y)

            bounding_box = np.array(
                [
                    row - buffer_pixel,
                    col - buffer_pixel,
                    row + buffer_pixel,
                    col + buffer_pixel,
                ]
            )

            buffered_point = dsm_diff.array[
                bounding_box[0] : bounding_box[2], bounding_box[1] : bounding_box[3]
            ]
            volume = estimate_volume(
                buffered_point[buffered_point != dsm_diff.no_data],
                dsm_diff,
            )
    else:
        volume = None

    return starting_point, volume</code></pre>
</details>
</dd>
<dt id="pearpy.starting_point2.find_starting_points"><code class="name flex">
<span>def <span class="ident">find_starting_points</span></span>(<span>input_earlier_dsm: str, input_later_dsm: str, input_flow_direction: str, input_flow_stream: str, max_percent_length: float, stream_buffer_size: float, return_processing_data: bool = False, progress_callback: typing.Optional[typing.Callable[[int, int], NoneType]] = None) ‑> typing.Tuple[typing.List[typing.Tuple[shapely.geometry.point.Point, float]], typing.Optional[<a title="pearpy.starting_point2.ProcessingData" href="#pearpy.starting_point2.ProcessingData">ProcessingData</a>]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_starting_points(
    input_earlier_dsm: str,
    input_later_dsm: str,
    input_flow_direction: str,
    input_flow_stream: str,
    max_percent_length: float,
    stream_buffer_size: float,
    return_processing_data: bool = False,
    progress_callback: Optional[Callable[[int, int], None]] = None,
) -&gt; Tuple[List[Tuple[Point, float]], Optional[ProcessingData]]:
    if progress_callback is not None:
        progress_callback(0, 0)
    processing_data = ProcessingData(input_flow_direction, input_flow_stream)

    try:
        print(processing_data.main_stem_vectorfile)
        print(&#34;r&#34;,input_earlier_dsm, input_later_dsm)
        with fiona.open(processing_data.main_stem_vectorfile) as lines, rasterio.open(
            input_earlier_dsm
        ) as earlier_dsm, rasterio.open(input_later_dsm) as later_dsm:
            earlier_dsm = dine.Raster.from_rasterfile(input_earlier_dsm)
            later_dsm = dine.Raster.from_rasterfile(input_later_dsm)

            if later_dsm.epsg != earlier_dsm.epsg:
                raise ValueError(&#34;Both dsm should be in the same reference system&#34;)

            dsm_diff = later_dsm - earlier_dsm

            starting_points: List[Tuple[Point, float]] = []
            sp_coordinates: np.ndarray = np.empty((1, 2), dtype=np.float32)

            features: Tuple[Tuple[int, GeoJsonDict], ...] = tuple(
                lines.items(
                    bbox=(
                        later_dsm.x_min,
                        later_dsm.y_min,
                        later_dsm.x_max,
                        later_dsm.y_max,
                    )
                )
            )

            progress_total = len(features)

            for i, feature in tqdm(features, total=len(features)):

                line = feature[&#34;geometry&#34;][&#34;coordinates&#34;]
                if later_dsm.xy_value(
                    *feature[&#34;geometry&#34;][&#34;coordinates&#34;][0]
                ) &lt; later_dsm.xy_value(*feature[&#34;geometry&#34;][&#34;coordinates&#34;][-1]):
                    line = feature[&#34;geometry&#34;][&#34;coordinates&#34;][::-1]

                stem = geometry.LineString(line)
                stem = ops.substring(stem, 0, stem.length * max_percent_length / 100)

                starting_point, volume = find_starting_point(
                    stem, 0.25, dsm_diff, processing_data.link_class, stream_buffer_size
                )
                if starting_point is not None and volume is not None:
                    near_sp_exist = any(
                        (
                            np.abs(sp_coordinates[:, 0] - starting_point.x)
                            + np.abs(sp_coordinates[:, 1] - starting_point.y)
                        )
                        &lt;= 3
                    )

                    if not near_sp_exist:
                        starting_points.append((starting_point, volume))

                if progress_callback is not None:
                    progress_callback(progress_total, i + 1)
            if return_processing_data:
                return starting_points, processing_data
            else:
                # processing_data.cleanup()
                return starting_points, None
    except Exception as e:
        processing_data.cleanup()
        raise e</code></pre>
</details>
</dd>
<dt id="pearpy.starting_point2.interpolate_points"><code class="name flex">
<span>def <span class="ident">interpolate_points</span></span>(<span>polyline: shapely.geometry.linestring.LineString, distance: float = 0.25, upstream: int = 0) ‑> typing.Generator[shapely.geometry.point.Point, NoneType, NoneType]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_points(
    polyline: geometry.LineString, distance: float = 0.25, upstream: int = 0
) -&gt; Generator[geometry.Point, None, None]:
    interpolate_distances = np.arange(polyline.length // distance) * distance
    interpolate_distances = np.append(interpolate_distances, polyline.length)
    for interpolate_distance in interpolate_distances:
        yield polyline.interpolate(interpolate_distance)</code></pre>
</details>
</dd>
<dt id="pearpy.starting_point2.save2txt"><code class="name flex">
<span>def <span class="ident">save2txt</span></span>(<span>starting_points: typing.List[typing.Tuple[shapely.geometry.point.Point, float]], output_location: typing.Union[pathlib.Path, str]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save2txt(
    starting_points: List[Tuple[Point, float]], output_location: Union[Path, str]
) -&gt; None:
    with open(output_location, &#34;w&#34;) as out:
        for starting_point, volume in starting_points:
            out.writelines(f&#34;{starting_point.x},{starting_point.y},{volume}\n&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pearpy.starting_point2.ProcessingData"><code class="flex name class">
<span>class <span class="ident">ProcessingData</span></span>
<span>(</span><span>flow_direction, flow_stream)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProcessingData:
    def __init__(self, flow_direction, flow_stream):
        self.temp_folder = TemporaryDirectory()
        self.temp_path = Path(self.temp_folder.name)
        self.flow_direction = flow_direction
        self.flow_stream = flow_stream

        self.main_stem_rasterfile = self.temp_path / &#34;main_stem.tif&#34;
        self.main_stem_vectorfile = self.temp_path / &#34;main_stem.shp&#34;
        self.link_class_file = self.temp_path / &#34;link_class.tif&#34;

        self.link_class: Optional[&#34;dine.Raster&#34;] = None

        self.generate()

    def generate(self) -&gt; None:
        wbt.find_main_stem(
            self.flow_direction,
            self.flow_stream,
            self.main_stem_rasterfile,
            esri_pntr=True,
        )
        wbt.stream_link_class(
            self.flow_direction, self.flow_stream, self.link_class_file, esri_pntr=True
        )
        wbt.raster_streams_to_vector(
            self.main_stem_rasterfile,
            self.flow_direction,
            self.main_stem_vectorfile,
            esri_pntr=True,
        )

        self.link_class = dine.Raster.from_rasterfile(str(self.link_class_file))
        print(&#34;processing data has been generated&#34;)

    def save(self, output_directory: Path) -&gt; None:
        # self.link_class.save(str(output_directory / &#34;link_class.tif&#34;))
        for f in self.temp_path.glob(&#34;*&#34;):
            if f.is_file():
                copy2(f.absolute(), output_directory)

    def cleanup(self) -&gt; None:
        self.temp_folder.cleanup()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pearpy.starting_point2.ProcessingData.cleanup"><code class="name flex">
<span>def <span class="ident">cleanup</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cleanup(self) -&gt; None:
    self.temp_folder.cleanup()</code></pre>
</details>
</dd>
<dt id="pearpy.starting_point2.ProcessingData.generate"><code class="name flex">
<span>def <span class="ident">generate</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate(self) -&gt; None:
    wbt.find_main_stem(
        self.flow_direction,
        self.flow_stream,
        self.main_stem_rasterfile,
        esri_pntr=True,
    )
    wbt.stream_link_class(
        self.flow_direction, self.flow_stream, self.link_class_file, esri_pntr=True
    )
    wbt.raster_streams_to_vector(
        self.main_stem_rasterfile,
        self.flow_direction,
        self.main_stem_vectorfile,
        esri_pntr=True,
    )

    self.link_class = dine.Raster.from_rasterfile(str(self.link_class_file))
    print(&#34;processing data has been generated&#34;)</code></pre>
</details>
</dd>
<dt id="pearpy.starting_point2.ProcessingData.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, output_directory: pathlib.Path) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, output_directory: Path) -&gt; None:
    # self.link_class.save(str(output_directory / &#34;link_class.tif&#34;))
    for f in self.temp_path.glob(&#34;*&#34;):
        if f.is_file():
            copy2(f.absolute(), output_directory)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pearpy.starting_point2.StemTooShort"><code class="flex name class">
<span>class <span class="ident">StemTooShort</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StemTooShort(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pearpy" href="index.html">pearpy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pearpy.starting_point2.calculate_volume_stem" href="#pearpy.starting_point2.calculate_volume_stem">calculate_volume_stem</a></code></li>
<li><code><a title="pearpy.starting_point2.estimate_volume" href="#pearpy.starting_point2.estimate_volume">estimate_volume</a></code></li>
<li><code><a title="pearpy.starting_point2.find_starting_point" href="#pearpy.starting_point2.find_starting_point">find_starting_point</a></code></li>
<li><code><a title="pearpy.starting_point2.find_starting_points" href="#pearpy.starting_point2.find_starting_points">find_starting_points</a></code></li>
<li><code><a title="pearpy.starting_point2.interpolate_points" href="#pearpy.starting_point2.interpolate_points">interpolate_points</a></code></li>
<li><code><a title="pearpy.starting_point2.save2txt" href="#pearpy.starting_point2.save2txt">save2txt</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pearpy.starting_point2.ProcessingData" href="#pearpy.starting_point2.ProcessingData">ProcessingData</a></code></h4>
<ul class="">
<li><code><a title="pearpy.starting_point2.ProcessingData.cleanup" href="#pearpy.starting_point2.ProcessingData.cleanup">cleanup</a></code></li>
<li><code><a title="pearpy.starting_point2.ProcessingData.generate" href="#pearpy.starting_point2.ProcessingData.generate">generate</a></code></li>
<li><code><a title="pearpy.starting_point2.ProcessingData.save" href="#pearpy.starting_point2.ProcessingData.save">save</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pearpy.starting_point2.StemTooShort" href="#pearpy.starting_point2.StemTooShort">StemTooShort</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>