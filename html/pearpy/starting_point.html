<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pearpy.starting_point API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pearpy.starting_point</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from dataclasses import dataclass
from pathlib import Path
from typing import Any, Callable, Dict, Generator, List, Optional, Tuple, Union

import fiona
import geosardine as dine
import numpy as np
import rasterio
from rasterio import Affine
from shapely import geometry, speedups
from shapely.geometry import LineString, Point
from tqdm.autonotebook import tqdm

from .custom_types import GeoJsonDict

speedups.disable()


def interpolate_points(
    polyline: geometry.LineString, distance: float = 0.25, upstream: int = 0
) -&gt; Generator[geometry.Point, None, None]:
    interpolate_distances = np.arange(polyline.length // distance) * distance
    interpolate_distances = np.append(interpolate_distances, polyline.length)
    if upstream == -1:
        interpolate_distances = interpolate_distances[::-1]
    for interpolate_distance in interpolate_distances:
        yield polyline.interpolate(interpolate_distance)


def get_vertices(
    features: Tuple[Tuple[int, GeoJsonDict], ...],
) -&gt; Generator[Union[Tuple[float, float, float], Tuple[float, float]], None, None]:
    for _, feature in features:
        yield feature[&#34;geometry&#34;][&#34;coordinates&#34;][0]
        yield feature[&#34;geometry&#34;][&#34;coordinates&#34;][-1]


def estimate_volume(array: np.ndarray, dsm_diff: dine.Raster) -&gt; float:
    return float(np.sum(array[array &gt; dsm_diff.no_data]) * dsm_diff.resolution[0])


def find_starting_point_in_line(
    line: LineString, upstream_index: int, dsm_diff: dine.Raster
) -&gt; Tuple[Optional[geometry.Point], Optional[float]]:
    interpolated = interpolate_points(line, upstream=upstream_index)
    buffer_pixel = 5
    buffer_area = (buffer_pixel * 2) ** 2
    minimum_pixel = buffer_area * 0.7
    candidate_points: List[Tuple[Point, float]] = []

    for point in interpolated:
        try:
            row, col = dsm_diff.xy2rowcol(point.x, point.y)

            bounding_box = np.array(
                [
                    row - buffer_pixel,
                    col - buffer_pixel,
                    row + buffer_pixel,
                    col + buffer_pixel,
                ]
            )
            if np.all(bounding_box &gt; 0) and dsm_diff.array[row, col] &gt; 0:
                buffered_point = dsm_diff.array[
                    bounding_box[0] : bounding_box[2], bounding_box[1] : bounding_box[3]
                ]
                deposition_pixel_count = (buffered_point &gt; 0).sum()
                if deposition_pixel_count &gt; minimum_pixel:
                    volume = estimate_volume(
                        buffered_point[buffered_point != dsm_diff.no_data], dsm_diff
                    )
                    candidate_points.append((point, volume))
        except IndexError:
            continue
    if len(candidate_points) == 0:
        return None, None
    else:
        return candidate_points[-1]


def find_upstream(
    feature: GeoJsonDict,
    vertices: np.ndarray,
    dsm: dine.Raster,
    dsm_diff: dine.Raster,
) -&gt; Optional[int]:
    vertices_diff_first = vertices - feature[&#34;geometry&#34;][&#34;coordinates&#34;][0]
    vertices_diff_last = vertices - feature[&#34;geometry&#34;][&#34;coordinates&#34;][-1]

    distance_to_first = np.abs(vertices_diff_first[:, 0]) + np.abs(
        vertices_diff_first[:, 1]
    )
    distance_to_last = np.abs(vertices_diff_last[:, 0]) + np.abs(
        vertices_diff_last[:, 1]
    )

    nearest_point_first = len(distance_to_first[distance_to_first == 0])
    nearest_point_last = len(distance_to_last[distance_to_last == 0])

    if nearest_point_last == 1 or nearest_point_first == 1:
        upstream_index = 0
        downstream_index = -1
        if nearest_point_last == 1:
            upstream_index = -1
            downstream_index = 0

        # z_upstream = dine.drape2raster(
        #     list(feature[&#34;geometry&#34;][&#34;coordinates&#34;][upstream_index]),
        #     dsm.array,
        #     dsm.affine,
        # )[2]
        # z_downstream = dine.drape2raster(
        #     list(feature[&#34;geometry&#34;][&#34;coordinates&#34;][downstream_index]),
        #     dsm.array,
        #     dsm.affine,
        # )[2]
        try:
            z_upstream = dsm.xy_value(
                *feature[&#34;geometry&#34;][&#34;coordinates&#34;][upstream_index]
            )
            z_downstream = dsm.xy_value(
                *feature[&#34;geometry&#34;][&#34;coordinates&#34;][downstream_index]
            )

            if z_upstream &gt; z_downstream and z_upstream != dsm.no_data:
                deposit_upstream = dsm_diff.xy_value(
                    *feature[&#34;geometry&#34;][&#34;coordinates&#34;][upstream_index]
                )
                deposit_downstream = dsm_diff.xy_value(
                    *feature[&#34;geometry&#34;][&#34;coordinates&#34;][downstream_index]
                )

                if (
                    deposit_upstream != dsm_diff.no_data
                    and deposit_downstream != dsm_diff.no_data
                ):
                    return upstream_index
        except IndexError:
            print(&#34;skipped&#34;)
            pass

    return None


def find_starting_point(
    feature: Dict[Any, Any],
    vertices: np.ndarray,
    dsm: dine.Raster,
    dsm_diff: dine.Raster,
) -&gt; Tuple[Optional[geometry.Point], Optional[float]]:
    _feature = GeoJsonDict(
        type=feature[&#34;type&#34;],
        id=feature[&#34;id&#34;],
        properties=feature[&#34;properties&#34;],
        geometry=feature[&#34;geometry&#34;],
    )

    if geometry.shape(_feature[&#34;geometry&#34;]).length &lt; 5.0:
        &#34;&#34;&#34;Filter by length&#34;&#34;&#34;
        return None, None

    upstream_index = find_upstream(_feature, vertices, dsm, dsm_diff)
    if upstream_index is not None:
        starting_point, volume = find_starting_point_in_line(
            geometry.LineString(_feature[&#34;geometry&#34;][&#34;coordinates&#34;]),
            upstream_index,
            dsm_diff,
        )

        return starting_point, volume
    return None, None


def find_starting_points(
    input_stream_vector: str,
    input_earlier_dsm: str,
    input_later_dsm: str,
    progress_callback: Optional[Callable[[int, int], None]] = None,
) -&gt; List[Tuple[Point, float]]:
    with fiona.open(input_stream_vector) as lines, rasterio.open(
        input_earlier_dsm
    ) as earlier_dsm, rasterio.open(input_later_dsm) as later_dsm:
        earlier_dsm = dine.Raster.from_rasterfile(input_earlier_dsm)
        later_dsm = dine.Raster.from_rasterfile(input_later_dsm)

        if later_dsm.epsg != earlier_dsm.epsg:
            raise ValueError(&#34;Both dsm should be in the same reference system&#34;)

        dsm_diff = later_dsm - earlier_dsm

        starting_points: List[Tuple[Point, float]] = []
        sp_coordinates: np.ndarray = np.empty((1, 2), dtype=np.float32)

        features: Tuple[Tuple[int, GeoJsonDict], ...] = tuple(
            lines.items(
                bbox=(
                    later_dsm.x_min,
                    later_dsm.y_min,
                    later_dsm.x_max,
                    later_dsm.y_max,
                )
            )
        )

        vertices = np.array(list(get_vertices(features)))
        progress_total = len(features)

        for i, feature in tqdm(features, total=len(features)):
            starting_point, volume = find_starting_point(
                feature, vertices, later_dsm, dsm_diff
            )
            if starting_point is not None and volume is not None:
                near_sp_exist = any(
                    (
                        np.abs(sp_coordinates[:, 0] - starting_point.x)
                        + np.abs(sp_coordinates[:, 1] - starting_point.y)
                    )
                    &lt;= 3
                )

                if not near_sp_exist:
                    starting_points.append((starting_point, volume))

            if progress_callback is not None:
                progress_callback(progress_total, i + 1)
        return starting_points


def save2txt(
    starting_points: List[Tuple[Point, float]], output_location: Union[Path, str]
) -&gt; None:
    with open(output_location, &#34;w&#34;) as out:
        for starting_point, volume in starting_points:
            out.writelines(f&#34;{starting_point.x},{starting_point.y},{volume}\n&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pearpy.starting_point.estimate_volume"><code class="name flex">
<span>def <span class="ident">estimate_volume</span></span>(<span>array: numpy.ndarray, dsm_diff: geosardine.raster.Raster) ‑> float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def estimate_volume(array: np.ndarray, dsm_diff: dine.Raster) -&gt; float:
    return float(np.sum(array[array &gt; dsm_diff.no_data]) * dsm_diff.resolution[0])</code></pre>
</details>
</dd>
<dt id="pearpy.starting_point.find_starting_point"><code class="name flex">
<span>def <span class="ident">find_starting_point</span></span>(<span>feature: typing.Dict[typing.Any, typing.Any], vertices: numpy.ndarray, dsm: geosardine.raster.Raster, dsm_diff: geosardine.raster.Raster) ‑> typing.Tuple[typing.Optional[shapely.geometry.point.Point], typing.Optional[float]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_starting_point(
    feature: Dict[Any, Any],
    vertices: np.ndarray,
    dsm: dine.Raster,
    dsm_diff: dine.Raster,
) -&gt; Tuple[Optional[geometry.Point], Optional[float]]:
    _feature = GeoJsonDict(
        type=feature[&#34;type&#34;],
        id=feature[&#34;id&#34;],
        properties=feature[&#34;properties&#34;],
        geometry=feature[&#34;geometry&#34;],
    )

    if geometry.shape(_feature[&#34;geometry&#34;]).length &lt; 5.0:
        &#34;&#34;&#34;Filter by length&#34;&#34;&#34;
        return None, None

    upstream_index = find_upstream(_feature, vertices, dsm, dsm_diff)
    if upstream_index is not None:
        starting_point, volume = find_starting_point_in_line(
            geometry.LineString(_feature[&#34;geometry&#34;][&#34;coordinates&#34;]),
            upstream_index,
            dsm_diff,
        )

        return starting_point, volume
    return None, None</code></pre>
</details>
</dd>
<dt id="pearpy.starting_point.find_starting_point_in_line"><code class="name flex">
<span>def <span class="ident">find_starting_point_in_line</span></span>(<span>line: shapely.geometry.linestring.LineString, upstream_index: int, dsm_diff: geosardine.raster.Raster) ‑> typing.Tuple[typing.Optional[shapely.geometry.point.Point], typing.Optional[float]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_starting_point_in_line(
    line: LineString, upstream_index: int, dsm_diff: dine.Raster
) -&gt; Tuple[Optional[geometry.Point], Optional[float]]:
    interpolated = interpolate_points(line, upstream=upstream_index)
    buffer_pixel = 5
    buffer_area = (buffer_pixel * 2) ** 2
    minimum_pixel = buffer_area * 0.7
    candidate_points: List[Tuple[Point, float]] = []

    for point in interpolated:
        try:
            row, col = dsm_diff.xy2rowcol(point.x, point.y)

            bounding_box = np.array(
                [
                    row - buffer_pixel,
                    col - buffer_pixel,
                    row + buffer_pixel,
                    col + buffer_pixel,
                ]
            )
            if np.all(bounding_box &gt; 0) and dsm_diff.array[row, col] &gt; 0:
                buffered_point = dsm_diff.array[
                    bounding_box[0] : bounding_box[2], bounding_box[1] : bounding_box[3]
                ]
                deposition_pixel_count = (buffered_point &gt; 0).sum()
                if deposition_pixel_count &gt; minimum_pixel:
                    volume = estimate_volume(
                        buffered_point[buffered_point != dsm_diff.no_data], dsm_diff
                    )
                    candidate_points.append((point, volume))
        except IndexError:
            continue
    if len(candidate_points) == 0:
        return None, None
    else:
        return candidate_points[-1]</code></pre>
</details>
</dd>
<dt id="pearpy.starting_point.find_starting_points"><code class="name flex">
<span>def <span class="ident">find_starting_points</span></span>(<span>input_stream_vector: str, input_earlier_dsm: str, input_later_dsm: str, progress_callback: typing.Optional[typing.Callable[[int, int], NoneType]] = None) ‑> typing.List[typing.Tuple[shapely.geometry.point.Point, float]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_starting_points(
    input_stream_vector: str,
    input_earlier_dsm: str,
    input_later_dsm: str,
    progress_callback: Optional[Callable[[int, int], None]] = None,
) -&gt; List[Tuple[Point, float]]:
    with fiona.open(input_stream_vector) as lines, rasterio.open(
        input_earlier_dsm
    ) as earlier_dsm, rasterio.open(input_later_dsm) as later_dsm:
        earlier_dsm = dine.Raster.from_rasterfile(input_earlier_dsm)
        later_dsm = dine.Raster.from_rasterfile(input_later_dsm)

        if later_dsm.epsg != earlier_dsm.epsg:
            raise ValueError(&#34;Both dsm should be in the same reference system&#34;)

        dsm_diff = later_dsm - earlier_dsm

        starting_points: List[Tuple[Point, float]] = []
        sp_coordinates: np.ndarray = np.empty((1, 2), dtype=np.float32)

        features: Tuple[Tuple[int, GeoJsonDict], ...] = tuple(
            lines.items(
                bbox=(
                    later_dsm.x_min,
                    later_dsm.y_min,
                    later_dsm.x_max,
                    later_dsm.y_max,
                )
            )
        )

        vertices = np.array(list(get_vertices(features)))
        progress_total = len(features)

        for i, feature in tqdm(features, total=len(features)):
            starting_point, volume = find_starting_point(
                feature, vertices, later_dsm, dsm_diff
            )
            if starting_point is not None and volume is not None:
                near_sp_exist = any(
                    (
                        np.abs(sp_coordinates[:, 0] - starting_point.x)
                        + np.abs(sp_coordinates[:, 1] - starting_point.y)
                    )
                    &lt;= 3
                )

                if not near_sp_exist:
                    starting_points.append((starting_point, volume))

            if progress_callback is not None:
                progress_callback(progress_total, i + 1)
        return starting_points</code></pre>
</details>
</dd>
<dt id="pearpy.starting_point.find_upstream"><code class="name flex">
<span>def <span class="ident">find_upstream</span></span>(<span>feature: <a title="pearpy.custom_types.GeoJsonDict" href="custom_types.html#pearpy.custom_types.GeoJsonDict">GeoJsonDict</a>, vertices: numpy.ndarray, dsm: geosardine.raster.Raster, dsm_diff: geosardine.raster.Raster) ‑> typing.Optional[int]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_upstream(
    feature: GeoJsonDict,
    vertices: np.ndarray,
    dsm: dine.Raster,
    dsm_diff: dine.Raster,
) -&gt; Optional[int]:
    vertices_diff_first = vertices - feature[&#34;geometry&#34;][&#34;coordinates&#34;][0]
    vertices_diff_last = vertices - feature[&#34;geometry&#34;][&#34;coordinates&#34;][-1]

    distance_to_first = np.abs(vertices_diff_first[:, 0]) + np.abs(
        vertices_diff_first[:, 1]
    )
    distance_to_last = np.abs(vertices_diff_last[:, 0]) + np.abs(
        vertices_diff_last[:, 1]
    )

    nearest_point_first = len(distance_to_first[distance_to_first == 0])
    nearest_point_last = len(distance_to_last[distance_to_last == 0])

    if nearest_point_last == 1 or nearest_point_first == 1:
        upstream_index = 0
        downstream_index = -1
        if nearest_point_last == 1:
            upstream_index = -1
            downstream_index = 0

        # z_upstream = dine.drape2raster(
        #     list(feature[&#34;geometry&#34;][&#34;coordinates&#34;][upstream_index]),
        #     dsm.array,
        #     dsm.affine,
        # )[2]
        # z_downstream = dine.drape2raster(
        #     list(feature[&#34;geometry&#34;][&#34;coordinates&#34;][downstream_index]),
        #     dsm.array,
        #     dsm.affine,
        # )[2]
        try:
            z_upstream = dsm.xy_value(
                *feature[&#34;geometry&#34;][&#34;coordinates&#34;][upstream_index]
            )
            z_downstream = dsm.xy_value(
                *feature[&#34;geometry&#34;][&#34;coordinates&#34;][downstream_index]
            )

            if z_upstream &gt; z_downstream and z_upstream != dsm.no_data:
                deposit_upstream = dsm_diff.xy_value(
                    *feature[&#34;geometry&#34;][&#34;coordinates&#34;][upstream_index]
                )
                deposit_downstream = dsm_diff.xy_value(
                    *feature[&#34;geometry&#34;][&#34;coordinates&#34;][downstream_index]
                )

                if (
                    deposit_upstream != dsm_diff.no_data
                    and deposit_downstream != dsm_diff.no_data
                ):
                    return upstream_index
        except IndexError:
            print(&#34;skipped&#34;)
            pass

    return None</code></pre>
</details>
</dd>
<dt id="pearpy.starting_point.get_vertices"><code class="name flex">
<span>def <span class="ident">get_vertices</span></span>(<span>features: typing.Tuple[typing.Tuple[int, <a title="pearpy.custom_types.GeoJsonDict" href="custom_types.html#pearpy.custom_types.GeoJsonDict">GeoJsonDict</a>], ...]) ‑> typing.Generator[typing.Union[typing.Tuple[float, float, float], typing.Tuple[float, float]], NoneType, NoneType]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vertices(
    features: Tuple[Tuple[int, GeoJsonDict], ...],
) -&gt; Generator[Union[Tuple[float, float, float], Tuple[float, float]], None, None]:
    for _, feature in features:
        yield feature[&#34;geometry&#34;][&#34;coordinates&#34;][0]
        yield feature[&#34;geometry&#34;][&#34;coordinates&#34;][-1]</code></pre>
</details>
</dd>
<dt id="pearpy.starting_point.interpolate_points"><code class="name flex">
<span>def <span class="ident">interpolate_points</span></span>(<span>polyline: shapely.geometry.linestring.LineString, distance: float = 0.25, upstream: int = 0) ‑> typing.Generator[shapely.geometry.point.Point, NoneType, NoneType]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_points(
    polyline: geometry.LineString, distance: float = 0.25, upstream: int = 0
) -&gt; Generator[geometry.Point, None, None]:
    interpolate_distances = np.arange(polyline.length // distance) * distance
    interpolate_distances = np.append(interpolate_distances, polyline.length)
    if upstream == -1:
        interpolate_distances = interpolate_distances[::-1]
    for interpolate_distance in interpolate_distances:
        yield polyline.interpolate(interpolate_distance)</code></pre>
</details>
</dd>
<dt id="pearpy.starting_point.save2txt"><code class="name flex">
<span>def <span class="ident">save2txt</span></span>(<span>starting_points: typing.List[typing.Tuple[shapely.geometry.point.Point, float]], output_location: typing.Union[pathlib.Path, str]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save2txt(
    starting_points: List[Tuple[Point, float]], output_location: Union[Path, str]
) -&gt; None:
    with open(output_location, &#34;w&#34;) as out:
        for starting_point, volume in starting_points:
            out.writelines(f&#34;{starting_point.x},{starting_point.y},{volume}\n&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pearpy" href="index.html">pearpy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pearpy.starting_point.estimate_volume" href="#pearpy.starting_point.estimate_volume">estimate_volume</a></code></li>
<li><code><a title="pearpy.starting_point.find_starting_point" href="#pearpy.starting_point.find_starting_point">find_starting_point</a></code></li>
<li><code><a title="pearpy.starting_point.find_starting_point_in_line" href="#pearpy.starting_point.find_starting_point_in_line">find_starting_point_in_line</a></code></li>
<li><code><a title="pearpy.starting_point.find_starting_points" href="#pearpy.starting_point.find_starting_points">find_starting_points</a></code></li>
<li><code><a title="pearpy.starting_point.find_upstream" href="#pearpy.starting_point.find_upstream">find_upstream</a></code></li>
<li><code><a title="pearpy.starting_point.get_vertices" href="#pearpy.starting_point.get_vertices">get_vertices</a></code></li>
<li><code><a title="pearpy.starting_point.interpolate_points" href="#pearpy.starting_point.interpolate_points">interpolate_points</a></code></li>
<li><code><a title="pearpy.starting_point.save2txt" href="#pearpy.starting_point.save2txt">save2txt</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>